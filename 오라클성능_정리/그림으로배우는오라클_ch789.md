## 오라클의 데이터 구조

### 가변 길이 데이터를 관리하기 위한 프로그램

```
[가변 길이 데이터는 관리가 힘듬]
1. 데이터를 변경할 때 문제가 있을 수 있음.
2. 동시에 처리가 불가능
	- 순서대로만 가능
3. 데이터 관리나 I/O가 힘듬
	- 양이 많아지면 힘듬
4. 사용하지 않는 공간의 관리가 힘듬
	- 데이터 없는 공간을 관리해야하나 양이 많아지면 힘듬
	
[해결]
1. 관리 및 I/O의 효율을 고려해 공간을 어느 정도의 크기로 뭉쳐서 할당
	- 각 테이블의 집합으로 뭉쳐서 관리
2. 데이터 변경에 필요한 공간을 확보해둠
3. 비어 있는 공간을 관리
	- 어느 정도의 크기마다 데이터 변경용 공간을 준비해둠
```



### 오라클의 데이터 구조

```
- 오라클의 데이터 구조는 물리 구조 및 논리 구조가 있음.
- 물리 구조
	- 데이터 파일 등의 OS에서 보이는 구조
- 논리 구조
	- OS에서는 식별할 수 없는 오라클 내부의 구조
	- 테이블 스페이스(창고), 세그먼트(물건 이름), 익스텐트(창고의 선반), 오라클 블록(정리함)
	
[익스텐트]
- 익스텐트는 연속된 블록의 집합
- 익스텐트의 도움으로 각 블록의 위치가 아니라 각 익스텐트의 첫 위치와 블록이 개수만으로 데이터를 관리할 수 있으며, 관리 정보도 줄일 수 있음.
- 익스텐트의 예
	- 데이터가 블록보다 길어질 시 블록을 여러개 걸쳐서 데이터 입력(예외동작)
	- 이로 인해서, 익스텐트로 블록을 연결해 정리
```



### 각 데이터 구조

```
[세그먼트]
- 많은 데이터를 보관하기 위한 구조(익스텐트 집합)
- 사용자용 세그먼트인 테이블이나 인덱스 이외에도 오라클이 자동적으로 생성하는 세그먼트도 있음
- 데이터를 정렬하기 위한 세그먼트나 언두라고 불리는 과거 데이터를 보관하는 세그먼트도 있음

[테이블 스페이스]
- 테이블 스페이스라고 부르긴 하지만, 세그먼트를 분류해서 보관하기 위한 상자라고 생각
- 한 개 애상의 데이터 파일로 구성됨
- 테이블 스페이스의 집합(물리적으로 데이터 파일의 집합)과 리두 로그 파일, 컨트롤 파일이 모이면 하나의 데이터베이스가 됨.

[블록 안의 공간]
- 오라클은 블록 안에 데이터를 입력할 때 어느 정도의 공간을 남겨둠.
- 빈 블록 관리
	- 세그먼트 안에 공간이 모자란 상황이 오면 세그먼트에 새로운 익스텐트를 추가하고 빈 블록 늘림.
	- 자동 세그먼트 영역 관리(ASSM)를 사용하고 있을 때는 오라클이 자동으로 판단

[ROWID]
- 데이터 행의 주소를 ROWID라고 부름
- ROWID는 데이터 파일의 번호나 데이터 파일 안의 블록 번호, 블록 안에 행 번호와 같은 정보로 구성됨
- 행 데이터는 블록에 보관되어 있음을 알 수 있음.
```



### 실제 흐름을 따라 각 동작을 확인

```
[공간 할당하기 및 비어 있는 공간의 관리]
1. 데이터베이스의 생성
	- 테이블 스페이스가 생성
2. 사용자용 테이블 스페이스의 생성
	- 사용자용 테이블 스페이스를 생성하는 것은 데이터베이스를 생성할 때 같이 해도 상관 없음.
3. 테이블을 테이블 스페이스에 생성
	- 이 시점에 몇가지 익스텐트가 생성됨.
	- 익스텐트 생성 후 데이터 입력이 수행되며, 익스텐트가 비어있는 블록에 데이터를 입력
	- PCTFREE라는 입계치에 도달하면 해당 블록에 입력하는 것을 멈추고 '이 블록에는 공간이 없어'라고 인식
	- 데이터의 입력이 계속되어 익스테늩가 가득차게 되면 테이블 스페이스가 가지고 있는 공간에서 새로운 익스텐트를 테이블에 할당하고 새로운 데이터를 입력할 수 있게 함
	- 테이블이나 인덱스가 DROP되면 익스테늩 안의 데이터는 불필요하므로 테이블 스페이스의 공간으로 돌아감
```



### 프로세스에서 본 데이터 구조

```
- 검색은 해당 테이블의 익스텐트를 조사하고 버퍼 캐시에 존재하지 않는 블록을 처음부터 읽어옴
- 변경은 인덱스를 사용해 한 건만을 대상으로 하는 변경
	- 우선 인덱스에 접근하고 인덱스의 관리 정보를 토대로 인덱스의 루트 블록을 찾아감, 캐시에 없다면 블록을 읽어옴
```



### 정리

```
- 테이블 스페이스는 세그먼트를 집어넣기 위한 용기로서 하나 이상의 데이터 파일로 구성
- 일반적으로 테이블이나 인덱스는 세그먼트
- 세그먼트는 익스텐트로 구성되며, 익스텐트는 연속한 블록으로 구성되어 있음.
- 세그먼트는 테이블 스페이스 여러 개에 걸쳐서 존재할 수 없음.
- 익스텐트는 데이터 파일 여러개에 걸쳐서 존재할 수 없음
- 일반적으로 테이블이나 인덱스는 테이블 스페이스가 가지고 있는 공간엣 ㅓ새로운 익스텐트를 할당받음으로써 크기가 커져 나감
- 블록 안이ㅡ 데이터 변경용 공간은 PCTFREE라느 파라미터로 제어
- 행은 블록에 보관
```



## 오라클의 대기와 락

### 데이터 베이스에 락이 필요한 이유

```
- UPDATE를 진행할 때 다중의 오라클 클라이언트가 동시에 같은 컬럼의 데이터를 변경 시 데이터가 의도하는대로 변경하기 어려움
- 이런 문제가 발생한 원인을 찾아보면 데이터를 확보하지 않았기 때문이라는 것을 알 수 있음.
- 락의 본질은 이렇게 다중 처리를 실현하기 위해 처리를 보호하는 것
- 행 락이 풀리는 시점은 커밋 또는 롤백할 때 풀림
- UPDATE문 등의 DML에는 자동으로 락을 걸어버림
```



### 대기와 락 대기

```
- 대기는 실제로 기다린다라는 것을 표시하는 것 뿐임
- 대기에는 '처리할 것이 없어서 쉬고 있는 대기', '이유가 있어 어쩔수 없이 하는 대기, 이상 상태 등 쓸데없이 SQL을 기다리게 하는 대기'가 있음
- 전자가 아이들 대기, 후자가 아이들이 아닌 대기

[아이들이 아닌 대기에 주의]
- 이유가 있어서 어쩔 수 없이 하는 대기는 정상적인 예로 디스크 I/O 대기가 있음
- 오라클은 SQL 처리 도중에 데이터가 필요해졌을 때는 디스크에서 블록을 읽어오며, 그때 대기가 발생
	- SQL 처리에 필요한 대기라고 함
- 이상 사태 등 쓸데없이 SQL을 기다리게 하는 대기는 판단하기가 어렵
	- 예를 들어 한 사용자가 어떤 테이블에 락을 걸어 버린 후에 식사하러 갔다 등이 있을 수 있음.
	
[락에 의한 대기란?]
- 락이 걸려 있는 대상에 다시 락을 걸려고 했을 때 대기가 발생
	- 락 걸려고 했는데 걸려 있어서 일단 대기
- 자주 볼 수 있는 락
	- TX : 행과 관련된 락
	- TM : 테이블에 거는 락

[데드락의 구조]
- 이름에서도 알 수 있듯이, 고장 나서 작동하지 않는 열쇠라고 생각하면 됨
- 서로가 상대방이 보유하고 있는 락을 기다리느라 영원히 처리를 진행할 수 없는 상태를 말함.
- 데드락(ORA-0060 발생)일 때는 오라클에 의해 자동으로 한쪽의 처리가 롤백되며, ALERT 파이로가 트레이스 파일에 정보가 표시됨
```



### 래치의 구조

```
- 래치도 다중 처리를 구현하기 위한 락
- 래치는 오라클 내부에서 자동으로 얻으며, SQL을 한번 실행하기 위해서는 여러 래치를 얻고 해제하기를 반복해야 함
- 래치는 메모리나 데이터를 조작할 대 상호 배타적으로 처리하지 않으면 데이터가 손상될 수 있는 경우를 보호하고자 사용

[래치의 경합]
- 프로세스 A가 래치를 갖고 있으나 CPU 권한이 없어서 대기 중..
- 프로세스 B는 CPU권한이 있는데 래치가 없어서 대기
- 무기한 대기..
```



### 정리

```
- 대기는 단순히 기다리고 있다는 상황을 표시하고 있는 것에 지나지 않음
- 아이들 대기 이벤트와 아이들이 아닌 대기 이벤트가 있음
- 락은 처리를 보호하기 위해 존재
- 데드락은 상대방이 소유하고 있는 락을 요청해서 처리를 진행하지 못하는 상태다
- 락 경합을 해소하기 위해서는 애플리케이션 측에서 대처해야 하는 때가 많다
- 래치는 오라클 내부의 중요한 것을 보호하기 위해 존재함
- 시스템이 대규모가 아닐 대 래치 경합이 심하다면 CPU 자원이 부족하거 페이징 등 바람직하지 않은 상태인지를 확인함
- 오라클을 제대로 운영하기 위해서는 토대가 되는 OS도 제대로 된 상태가 아니면 안됨
```



## 리두와 언두의 동작

### 리두와 언두를 왜 배워야 하는 가?

```
- 리두와 언두에 대한 설명에 들어가기에 앞서 ACID 특성이 대체 무엇인지를 먼저 보도록 함

[ATOMICITY 원자성]
- 트랜잭션에 포함되는 데이터 변경은 전부 OK이거나 모두 NG라는 all or nothing임.
- DBMS는 트랜젝션의 데이터 일부만을 변경할 수 없음

[OCNSISTENCY 일관성]
- 트랜잭션에 의해 데이터 간의 일관성이 어긋나서는 안됨
- 고객 테이블의 데이터가 변경됐는데도 고객 테이블의 인덱스 데이터는 변경되지 않음

[ISOLATION 고립성]
- 트랜잭션끼리는 고리보디어 있으며 독리보디어 있다는 의미
- 어떤 트랜잭션을 단독으로 실행했거나 다른 트랜잭션과 동시에 실행하더라도 결과는 같아야 한다는 것

[DURABILITY 지속성]
- 커밋한 트랜잭션의 장애가 발생하더라도 데이터는 반드시 복구되어야 함

[ACID 특징]
- 일관성 : 데이터 변경 시 인덱스도 변경되어야 함
- 지속성 : 장비가 거지더라도 커밋한 데이터는 복구할 수 있어야 함
- 원자성 : 어중간한 데이터 변경은 안됨
- 트랜잭션 단위로 변경되어야 함
- 다른 트랜잭셔노가 동시에 실행하든 하지 않든 결과는 같아야 함
```



### 리두와 언두의 개념

```
- 리두 로그 : 누군가 무엇을 했다는 정보
- 언두 : 어떻게 하면 과거의 상태로 돌아갈 수 있는지에 관한 정보

- 리두 로그를 사용해서 과거의 데이터를 최신 데이터 쪽으로 흐르게 하는 것을 롤 포워드라고 함
- 언두의 정보를 사용해서 변경을 취소하는 것을 롤백이라고 함.
```



### 리두의 아키텍처

```
- 데이터의 변경은 캐시 위에서 이루어짐 그 때, 리두 로그라고 불리는 로그 데이터가 생성됨
- 리두 로그용 메모리로서 리두 로그 버퍼가 공유 메모리에 존재함
- 리두 로그를 디스크에 기록하는 것은 LGWR이라고 불리는 프로세스임
- 리두 로그 파일이 일시적인 리두 로그의 보관 창고이며, 아카이브 리두로 그 파일이 오랜 시간 보관할 수 있는 본격적인 보관 창고
- 리두 로그 파일은 매우 중요한 파일이므로 반드시 다중화

[프로세스의 동작 수준]
1. 서버 프로세스는 커밋했을 때 LGWR 프로세스에 리두 로그를 기록하도록 의뢰함
2. 의뢰를 받은 LGWR 프로세스는 리두 로그를 리두 로그 파일에 기록함
3. 기록이 끝나면 LGWR 프로세스가 서버 프로세스에 기록이 끝났다고 통보함
4. 서버 프로세스는 커밋이 끝난 것을 오라클 클라이언트에게 통보
```



### 리두의 정리

```
- 병렬 처리를 가능케하고 높은 처리량을 실현함
	- 리두 로그를 기록하는 데에서도 LGWR은 여러 서버 프소세스의 리두 로그를 한 번에 기록하기 때문에 높은 처리량을 구현할 수 있음.
- 응답을 중시함
	- 커밋할 때 블록을 디스크에 기록하지 않고 리두 로그에 기록하는 것으로 빠른 커밋을 구현할 수 있음
- 커밋한 데이터는 지킴
	- 장비에 장애가 발생하여 DBWR이 데이터를 기록할 틈도 없었다고 가정하더라도 그 후에 리두 로그와 데이터 파일에 남아 있는 오래된 데이터를 사용해서 데이터를 복구(롤 포워드) 할 수 있음.
```



### 언두의 아키텍처

```
- 데이터가 변경되면 언두 정보가 생성됨.
- 언두 정보는 세그먼트에 보관되어 있음
- 세그먼트에 보관되어 있으므로 어딘가의 테이블 스페이스에 보관되어 있다는 것을 알 수 있으며, 해당 테이블 스페이스를 언두 테이블 스페이스라고 부름.
- 언두 테이블 스페이스에는 여러 개의 언두 세그먼트가 생성됨
- 언두 세그먼트는 링 버퍼 인데, 링 버퍼는 조금 지나면 데이터가 덮어싀워지는 버퍼지만, 커미사힞 않은 데이터는 덮어써지지 않음
- 언두 세그먼트는 일정 기간 데이터를 보관하면 한 바퀴 돈 후 이전 데이터를 덮어쓰기 때문에 링과 같은 모양으로 표시함.
```



### 리두와 언두의 동작

```
[롤백할 때의 동작]
- 롤백이 수행된다면 언두 정보를 사용하는 것으로 데이터를 원래의 값으로 변경

[읽기 일관성에 동반되는 동작]
- 데이터를 검색할 대 어떤 시점의 데이터를 보여주는 기능을 말함
- 검색 중에는 계속해서 검색을 시작한 시점의 데이터를 보여주는 것을 말함
- 이런 읽기 일관성을 위해서 언두를 사용함
- 읽기 일관성은 데이터가 변경된 시점을 확인하고, 검색을 시작한 후에 변경된 데이터일 때는 언두를 사용해서 메모리 위에 과거의 데이터를 재현

[커밋되지 않은 데이터를 읽어 올 때의 동작]
- 다른 세션의 커밋한 변경 데이터는 읽을 수 잇음
- 다른 세션의 커밋되지 않은 변경 데이터를 읽어 올 수는 없음
- 이런 때도 읽기 일관성과 마찬가지로 변경되기 이전의 데이터를 보여줌

[ORA91555 에러가 발생했을 때의 동작]
- 이 에러는 과거의 데이터를 보러 갔으나 필요한 정보가 없어졌다라는 것을 의미함
- 대부분 시간이 오래 걸리는 검색을 할 대 언두 정보가 덮어써진 것이 원인
- 시간이 길어지고 데이터를 많이 변경하면 언두 정보가 덮어씌워짐
	- UNDO RETENTION을 길게 혹은 언두 테이블 스페이스를 확보 후 UNDO RETENTION을 조정해야 함
	
[체크포인트의 동작]
- 체크포인트는 메모리의 데이터를 디스크와 동기화하는 작업을 말함.
- 구체적으로는 DBWR이 메모리에서 디스크로 데이터를 기록
- 체크포인트에 의해 정기적으로 데이터를 디스크에 기록하고 롤 포워드에 걸리는 시간을 줄일 수 있도록 하고 있음.
	- 캐시 말고 DATA FILE의 DATA와 리두 로그 파일을 사용해서 실시간 DATA를 복원

[인스턴스 복구 시의 동작]
- 컴퓨터는 돌발적으로 장애가 발생할 수 있음
- 데이터 파일에 리두 로그를 적용하고 데이터를 최신 상태로 갱신
	- 이 때, 난감한 부분은 커밋하지 않은 데이터를 어떻게 처리할 지인데, 언두를 활용하여 롤백하여 원자성을 지킴
- 실은 언두의 갱신 정보도 리두 로그에 들어가 있기 때문에 롤 포워드함으로 언두를 최신 상태로 만듬
- 기동할 때 자동으로 수행되는 이런 복구를 인스턴스 복구라고 부름.
```



### 정리

```
- 리두는 오래된 데이터를 최신 데이터로 만들기 위해 존재
- 언두는 최신 데이터를 오래된 데이터로 만들기 ㅜ이해 존재
- 읽기 일관성을 위해 언두를 사용
- ORA-01555가 발생 시 우선 undo_retention이나 언두 테이블 스페이스의 크기를 튜닝할 것을 검토
- 장비에 장애가 발생하거나 인스턴스가 비정상 종료했을 때는 리두와 언두를 사용해서 데이터를 복구하고 커밋하지 않은 데이터의 롤백을 수행
```

