## I/O와 디스크의 관계

### 오라클과 디스크(하드디스크)

~~~
- 오라클 시점에서 DB는 오라클이 관리하는 디스크에 들어있는 데이터를 의미
- 즉, 오라클이 다루는 데이터는 디스크에서 꺼내 오고 디스크로 돌아가는 것을 말함
- 디스크의 회전과 액추에이터의 동작으로 인해 디스크 위의 여러 곳에 있는 데이터를 읽어오는 것이 가능
~~~

### 디스크의 동작

~~~
- 시크 : 데이터 읽기
- 데이터를 I/O할 시 헤드가 움직이고, 회전해 오기를 기다려 시간이 오래 걸림

[I/O 대기시간 줄이기]
- 시퀀셜 액세스
	- 풀 스캔 시 메모리에 데이터가 없으면 시퀀셜 액세스가 발생
	- 테이블 크기가 크기 되면 성능적으로 불만족
- 인덱스
	- 그래서 나온게 인덱스
	- 인덱스는 색인할 때 사용하는 키 값과 그 키가 존재하고 있는 위치(rowid)가 기록되어 있음
	- 인덱스를 이용한 처리 흐름
		1. 디스크에서 인덱스를 읽음
		2. 읽어 온 인덱스를 조사하여 어드레스를 캐치
		3. 어드레스를 통해 디스크에서 데이터를 읽음
		4. 읽어온 데이터에서 찾고자 하는 데이터를 발견
- 랜덤 액세스
	- 보통 필요한 데이터가 디스크의 연속적으로 있지 않으므로, 디스크 위에서 헤드를 움직여가며 띄엄띄엄 접근하게 되는데, 이런 방식을 랜덤 액세스라고 함. -> 시퀀셜 액세스의 반대
~~~

### 데이터를 보증하기 위한 디스크

~~~
- 오라클의 프로세스가 비정상적으로 종료했다고 해도 데이터는 무사
- why? 데이터를 변경 후 커밋이라고 입력하면 오라클은 데이터를 디스크에 기록
	- 디스크에 기록 시 비정상적인 종료에도 데이터 보존이 가능
~~~



## 오라클의 여러 프로세스

### 데이터베이스의 데이터는 모두의 것

~~~
[DB를 공유]
- DB를 사용하지 않는 애플리케이션은 같은 프로그램이 여러개 실행 되더라도 실제로 변수는 개개인 프로그램마다 존재
- DB에서는 여러 프로세스나 사용자가 하나의 DB에 접근 즉, DB를 서로 공유
~~~

~~~
[프로세스와 스레드]
- 프로세스는 실행 상태에 있는 프로그램을 의미
- 프로세스를 다르게 비유해보면 프로그램이라는 거리에서 일하는 사람과 같음

- 스레드는 프로세스 내에 존재하는 실행 단위
- 하나의 프로세스 안에서 처리를 병렬로 하고 싶을 때 사용
~~~

~~~
[액셀과 DBMS의 차이]
- 엑셀은 하나의 PC에서 작동하며, 단일 사용자가 사용하는 것

- DBMS는 여러 사용자나 애플리케시연이 데이터를 공유한다는 전제로 만들어져 있어 여러 사용자가 동시에 데이터를 검색하거나 갱신 가능
- 여러 사용자가 사용하기 때문에 실수로 데이터가 이상해지지 않도록 '락'이라는 장치를 가지고 있음.
~~~

### 오라클이 여러 개의 프로세스로 구성되는 이유

~~~
1. 다중 처리를 하고 싶기 때문 - SQL 처리는 길게 몇 시간이 걸리는 경우도 있는데, 이 때 다른 사용자도 기다리게 할 수는 없음
2. 디스크는 메모리 액세스에 비해서 속도가 매우 느리기 때문임 - CPU와 같은 자원을 쉬게 하는 것은 매우 아까움
	- 여기서 CPU 자원이 아깝다는 것은 CPU를 최대한 분할하여 많이 쓸수 있도록
~~~

### 서버 프로세스와 백그라운드 프로세스

~~~
- 서버 프로세스 : 오라클 클라이언트에 직접 서비스하는 프로세스를 말함
- 백그라운드 프로세스 : 서버 프로세스와는 달리 오라클 클라이언트에 직접 서비스하지는 않는다. 전면에 나서지 않는 스태프에 해당하는 프로세스를 말함
~~~

### 각 프로세스 수행 목록

~~~
- SQL문의 수신
- SQL문의 파싱
- 데이터 읽기
- 데이터 기록
- SQL문의 결과 회신
- 로그 기록
- 각종 정리
- 로그 보관
~~~

### 프로세스 역할 분담(디스크 기록)

~~~
- 데이터 기록은 SQL문의 결과를 회신하는 것과는 상관없으며, 시간을 의미없이 사용하기 때문에 불필요하다고 볼 수 있다.
- 이렇게 SQL문의 결과를 회신하기 위해서 불필요한 처리는 다른 사람에게 맡겨버리면 됨. - DBWR이 수행해줌(백그라운드 프로세스)

- 즉, SQL의 결과를 회신하는데 필요한 것은 서버 프로세스가 수행하고 그 이외의 것은 백그라운드 프로세서가 수행함. 
~~~

### 오라클을 구성하는 프로세스와 역할

![ch123_그림1](https://user-images.githubusercontent.com/40616436/69542723-68da3800-0fcf-11ea-8d9c-5d30d16a77b1.jpg)

~~~
- 병렬 처리를 가능케 하고 높은 처리량을 실현함 및 응답을 중시함
~~~



## 캐시와 공유 메모리

**가능한 한 디스크에서 처리하지 않게 하려고 '캐시'라고 불리는 기술을 사용**

### 캐시란 대체 무엇인가

~~~
빈번하게 사용하는 데이터를 매번 디스크에서 꺼내 오지 않고 캐시라고 불리는 메모리에 둠으로써 빠르게 사용할 수 있도록 하는 것.
~~~

### 캐시 저장소 위치

![ch123_그림2](https://user-images.githubusercontent.com/40616436/69542754-768fbd80-0fcf-11ea-8516-0372a027bba3.jpg)

**버퍼 캐시에 데이터가 적재되어 있지 않을 때는 속도가 느린 디스크에서 데이터를 꺼내올 수밖에 없으므로 그만큼 SQL의 처리가 늦어짐.**

### 데이터는 블록 단위로 관리 됨

~~~
- 오라클은 블록이라고 하는 단위로 데이터를 관리
- I/O의 단위도 블록을 기반으로 하고 있으며, 버퍼 캐시도 블록 단위로 관리하고 있음.
~~~

### 블록과 캐시

~~~
- 한 개의 블록에는 여러 건의 데이터가 보관돼 있으므로 한 건만을 디스크에서 읽어 오려고 해도 필요한 데이터를 포함한 블록 자체가 케시에 보관 -> 보통 8KB
~~~

### 캐시의 사용으로 인덱스 검색을 효율적으로 - 단계가 있는 인덱스에서 Data 찾기

~~~
1. Select문에 의해 서버 프로세스는 캐시를 확인 후 없을 시 인덱스의 선두 블록을 디스크에서 읽어 옴(10밀리초)
2. 캐시에 선두 블록이 있는지 확인 후 없을 시 디스크에 접근 그 후 단계적으로 캐시 및 디스크에 왔다갔다 진행(10밀리초 *2)
3. 마지막 블록을 디스크에 찾아옴(10밀리초)

총 42밀리초 소요
	- 40밀리초는 캐시 및 디스크 확인한 시간
	- 2밀리초는 캐시에 데이터가 있을 시 시간
	
즉, 캐시에 데이터가 있을 시 속도가 대량 향상
~~~

### 프로세스는 공유한다(공유 메모리)

~~~
- 기본적으로 다른 프로세스의 메모리를 보는 것은 불가능 Why? 데이터에 손상을 입히지 않도록 Os가 보호하고 있음
- 공유 메모리를 사용하면 자신의 메모리 영역에 기록했던 데이터를 다른 프로세스에서도 즉시 볼 수 있음.
- SGA(System Global Area) : 공유 메모리
- PGA(Program Global Area) : 비공유 메모리
~~~

### 공유 메모리 성능

~~~
- 공유 메모리는 누구든지 접근할 수 있으므로 락을 걸어서 베타 제어를 하지 않으면 데이터에 손상을 입힐 수도 있음
- 이 말은 곧 DBMS의 내부에 많은 락이 존재하며, 이로 인해 성능 문제가 발생하기 쉽다는 것을 의미
~~~

### 세마포어

~~~
자원을 순서대로 쓰기 위해 OS가 제공하는 자원 관리 장치
~~~

### 버퍼 캐시 정리 -> LRU 알고리즘

~~~
- 버퍼 캐시의 크기는 한정되어 있으므로 누군가가 어떤 식으로든 관리하고 정리해야 함
- 이 때, 사용하는 LRU 알고리즘을 사용 -> 최근에 사용하지 않은 데이터부터 캐시아웃한다.
~~~

### DBWR

~~~
SQL 처리와는 관계없이 정기적으로 변경된 블록을 찾아 디스크에 보관하는 역할
~~~

**FullScan은 캐시에 적재하지 않음**

### 스토리지 캐시

![ch123_그림3](https://user-images.githubusercontent.com/40616436/69542776-80b1bc00-0fcf-11ea-930c-f4923e691e5d.jpg)

### OS 버퍼 캐시

~~~
- OS의 버퍼 캐시는 오라클의 버퍼 캐시와 비슷한 기능을 가짐
- OS에서는 가상 메모리라고 불리는 기능을 이용해 실제 가지고 있는 물리 메모리보다 많은 메모리를 사용 가능
	- 이때, 메모리에서 사용 빈도가 낮은 데이터를 디스크에 보관함
	- 프로세스에서 보면 데이터는 메모리에 있는 것처럼 보이지만, 실제로는 디스트에 보관된 구성임.
~~~

### OS의 파일 캐시와 가상 메모리

**OS의 파일 캐시와 동작**

![ch123_그림4](https://user-images.githubusercontent.com/40616436/69542821-8effd800-0fcf-11ea-8797-a314da01c0ec.jpg)

**가상 메모리와 페이징**

![ch123_그림5](https://user-images.githubusercontent.com/40616436/69542842-958e4f80-0fcf-11ea-851c-ddc35383e913.jpg)

### OS버퍼 캐시와 가상 메모리2

~~~
- 페이지 아웃 : 물리 메모리에서 디스크에 페이지를 기록하는 것
- 페이지 인 : 디스크에서 물리 메모리에 페이지를 읽어 오는 것

- 가상 메모리는 버퍼 캐시와는 반대로 동작한다고 생각할 수 있음
	- 버퍼 캐시는 사용할 수 있는 메모리의 양을 줄이고 디스크에 접근하는 것을 빠르게 하는 기술
	- 가상 메모리는 속도가 느린 디스크를 사용해서 사용할 수 있는 메모리의 양을 늘리는 기술
~~~

