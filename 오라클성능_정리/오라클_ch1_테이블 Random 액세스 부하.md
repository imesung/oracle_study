## 테이블 Random 액세스 부하

**대량의 데이터를 처리할 대 테이블 Random 액세스가 가장 큰 부하 요인으로 작동하는 원인**



### 인덱스 ROWID에 의한 테이블 액세스

~~~
- 쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 후 '테이블 Random 액세스' 가 발생
~~~

**오라클과 메인 메모리 DB와의 비교**

~~~
- 메인 메모리 DB : 데이터를 모두 메모리에 로드해놓고 메모리릍 통해서만 I/O를 수행하는 DB
- 오라클과 메인 메모리 DB
	- 오라클 : 디스크 상의 주소정보를 담고, 테이블 블록이 버퍼 캐시에 접근하여 캐싱 가능 여부를 본 후 불가능 시 다른 공간으로 밀려나게 되므로 인덱스에서 직접적으로 포인터로 연결 불가능
		- 그로 인해, 디스크 상의 블록 위치정보(DBA)를 해시키 값으로 삼아 버퍼 블록을 찾음
	- 메인 메모리 DB : 모든 데이터가 메모리에 저장되어 있어, 인덱스가 포인터로 연결되어 있음.
~~~

**인덱스 ROWID 액세스가 느린 이유**(rowid는 우편주소에 해당)

~~~
- 오라클에서의 rowid는 우편주소에 해당하고, 메인 메모리 DB에서 포인터는 전화번호에 해당
	- 전화번호는 번호만 알시 전화만 걸면 되는데, 우편주소는 우편번호를 확인 후 주소를 일일이 찾아다녀야 함. 즉, 전화번호보다 빠르기가 힘듬..
~~~

**ROWID로 데이터 찾기**

~~~
1. 하나의 rowid를 읽고 해시 값을 확인
2. 해시 체인은 해시값이 가리키는 해시 체인에 대한 래치를 얻으려고 시도
3. 만약 다른 프로세스가 래치를 잡고 있으면 래치가 풀렸는지 확인하는 작업을 일정 횟수 반복
4. 실패 시, CPU를 OS에 반환하고 대기상태에 빠짐 - latch free 대기 이벤트 발생
5. 다시 깨어날 시 래치 상태를 확인
6. 래치 해제 시, 래치를 획득하여 원하던 해시 체인으로 진입
7. 테이블 블록을 찾게 되면 래치를 해제 후 읽으면 된, 해당 블록을 액세스 한 프로세스가 아직 일을 끝내지 못해 버퍼 Lock을 쥔 상태라면 다시 대기
8. 버퍼 Lock을 해제야해 하므로 다시 해시 체인 래치를 얻으려고 시도(2로 다시 돌아감)
~~~

**해시 체인 스캔 시 데이터 블록 못찾을 경우** - 플랜 : Table Access By Index ROWID

~~~
1. 디스크로부터 블록을 퍼 올리려면 우선 Free 버퍼를 할당 받아야 하므로 LRU 리스트를 스캔
2. cache buffers lru chain 래치를 얻어야하는데, 래치 경합이 심할 시 여기서도 latch free 이벤트 발생
3. LRU 리스트 임계치만큼 스캔해도 버퍼를 찾지 못하면 DBWR에게 Dirty 버퍼를 디스크에 기록해 Free 버퍼를 확보해달라는 신호를 보냄
4. 해당 작업이 끝날 때까지 대기 상태에 빠지는데, 이때 free buffer waits 대기 이벤트 발생
5. 읽은 블록을 LRU 리스트 상에서 위치를 옮겨야 하기 때문에 다시 cache buffers lru chain 래치를 얻어야 하는데, 이 또한 원할하지 않을 경우 latch free 이벤트가 발생
~~~



### 인덱스 클러스터링 팩터(CF)

~~~
데이터가 물리적으로 뭉쳐있어야 좋고, 물리적으로 흩어져 있을 시 나쁘다.
~~~

**군집성 계수(=데이터가 모여 있는 정도)**

~~~
- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
	Ex) '거주지역 = 제주'에 해당하는 고객 데이터가 물리적으로 근접해있다면 데이터 찾는 속도가 빠름 
~~~

**CF 계산**

~~~
- CF 수치가 테이블 블록에 가까울수록 데이터가 잘 정렬돼 있음을 의미하고, 레코드 개수에 가까울수록 흩어져 있음을 의미

1. counter 변수를 하나 선언
2. 인덱스 리프 블록을 첨부터 끝까지 스캔하면서 인덱스 rowid로 부터 블록 번호를 취함
3. 현재 리프 블록과 직전 레코드 블록의 번호가 다를 시 count++
4. 최종 counter 변수 값을 CF로서 인덱스 통계에 저장
~~~

**인덱스를 이용한 TB 액세스 계산**

~~~
비용 = blevel(브랜치 블록 개수) +
		(리프 블록 수 * 유효 인덱스 선택도) + 
			=> 조건절에 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율
		(CF * 유효 테이블 선택도)			
			=> 스캔 완료 후 최종적으로 테이블을 방문할 것으로 예상되는 비율
~~~

**CF와 논리적 I/O**

~~~
- 인덱스 CF는, 인덱스를 경유해 테이블 전체 row를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수
- CF 가장 좋을 시 : CF가 전체 테이블 블록 개수와 일치
- CF 가장 나쁠 시 : CF가 총 레코드 개수와 일치
~~~

**버퍼 Pinning에 의한 논리적 I/O 감소 원리**

~~~
- 버퍼 Pinning: 방금 액세스한 버퍼에 대해 Pin을 즉각 해제하지 않고 DB Call 내에서 계속 유지하는 기능
	- 그로 인해 연속된 인덱스 레코드가 같은 블록을 가리킨다면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽어 논리적인 블록 읽기 횟수가 증가하지 않음.
	- 즉, CF가 좋을수록 논리적 읽기는 줄어든다!
~~~



### 인덱스 손익분기점

~~~
- 선택도가 높은 인덱스는 효용가치가 낮지만 대용량 테이블을 Full Scan하는 것 역시 비효율이 큼
	- 이 때, 오라클이 제공하는 기능을 잘 활용 시 인덱스의 손익분기점 한계를 극복 가능
~~~

**손익분기점을 극복하기 위한 기능들**

~~~
1. IOT(Index-Organized Table)로서, 테이블을 인덱스 구조로 생성하는 것을 말함
	- 테이블 자체가 인덱스 구조이므로 항상 정렬, 리프 블록이 곧 데이터 블록이어서 수직 탐색 후 테이블 레코드를 읽기 위한 추가적인 Random 액세스가 불필요
2. 클러스터 테이블
	- 키 값이 같은 레코드는 같은 블록에 모이도록 저장하여, 클러스터 인덱스를 이용할 시 테이블 Random 액세스가 키값별로 한번씩만 발생
3. 파티셔닝
	- 클러스터는 기준 키값이 같은 레코드를 블록 단위로 모아 놓지만, 파티셔닝은 세그먼트 단위로 모아 놓음
~~~



## 테이블 Random 액세스 최소화 튜닝

**테이블 Random 액세스 최소화를 위한 튜닝 방안과 사례를 소개**



### 인덱스 컬럼 추가

**무작정 인덱스 추가 시 오류 - 인덱스 = [deptno + job] 순으로 구성된 인덱스 하나 있음**

~~~
from epm
where deptno = 30
  and sal >= 2000;
  
- 인덱스 구성을 [deptno + sal]로 바꿔주면 좋겠지만 실운영에서는 인덱스 구성을 쉽게 바꾸기 어렵.
	- 기존 인덱스에 sal 컬럼을 추가하는 것만으로 테이블 Random 액세스 횟수를 줄여줄 수 있음.

- 사례.
	- 사용여부 Y, N 둘다 모두 탐색 but, 사용여부 Y를 추가함으로 써, 튜닝 완료
~~~



### PK 인덱스에 컬럼 추가

**단일 테이블을 PK로 액세스할 때는 단 한건만 조회하는 것이므로 테이블 Random 액세스도 단 1회만 발생하나, NL 조인할 때 Inner쪽에서 액세스될 때는 Random 액세스 부하가 만만치 않음**

~~~
emp를 기준으로 NL을 조인하고, 조인에 성공한 14건 중 loc='NEW YORK'인 레코드만 취하므로 최종 결과는 3건뿐.

select *
  form emp e, dept d
 where d.dpetno = e.deptno
   and d.loc = 'NEW YORK';
- loc 컬럼을 인덱스로 추가할 시 불필요한 11번의 random 액세스를 없앨수 있지만 PK 인덱스에는 추가할 수 없음.
	- Non-Unique 인덱스를 사용
~~~

**Non-Unique 인덱스 사용**

~~~
- PK 제약과 인덱스를 다시 만듬
	- pk는 deptno, 인덱스는 deptno, loc 모두 다시 만듬

- 주의 사항
	- PK 제약을 위해 사용되는 인덱스는 PK 제약 순서와 서로 일치하지 않아도 상관 없음.
	- 중복값 유무를 체크하는 용도이므로 PK 제약 컬럼들이 선두에 있기만 하면 됨
	
- A, B, C 가 PK 제약 컬럼 구성
	- A+B+C (0)
	- B+A+C+D+E (0)
	- A+C+B+D (0)
	- A+D+B+C (x)
~~~



### 인덱스만 읽고 처리

~~~
- 테이블 Random 액세스가 아무리 많더라도 필터 조건에 의해 버려지는 레코드가 거의 없다면 거기에 비효율은 없다
	- 이때 튜닝은! 아예 테이블 액세스가 발생하지 않도록 필요한 모든 컬럼을 인덱스에 포함시키는 방법이 있음
	- 즉, 인덱스만 읽고 처리하는 쿼리인 Covered 쿼리로 만듬
~~~



### Pinning 버퍼 활용

~~~
- 한번 입력된 테이블 레코드는 절대 rowid가 바뀌지 않으므로, 미리 알고 있던 테이블 rowid값을 이용해 레코드를 조회하는 것이 가능
	- 즉, 인덱스 전체를 스캔해 얻은 레코드를 rowid 순으로 정렬한 다음 한건씩 순차적으로 emp 테이블 액세스하는 데 이 때, 버퍼 Pinning 효과를 나타낼 시 한번의 액세스로 블록 안에 있는 모든 레코드를 읽을 수 있음.
~~~



### 수동으로 클러스터링 팩터 높이기

~~~
- 테이블은 무작위로 입력되는 반면, 인덱스는 정해진 키 순으로 정렬되기 때문에 CF가 좋지 않게 만들어진다. 이때의 튜닝은?
	- 인덱스 기준으로 테이블을 재생성함으로써, CF를 인위적으로 좋게 만드는 방법을 생각해볼수 있음.
	
1. 가장 자주 사용되는 인덱스를 기준으로 삼음
2. 다른 인덱스를 사용하는 중요한 쿼리 성능에 나쁜 영향을 주지 않는지 반드시 체크
~~~





















