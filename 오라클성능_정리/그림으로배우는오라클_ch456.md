## SQL문 분석과 공유 풀

**처리방법의 생성(분석)과 생성 후 캐시하는 저장소(공유 풀)**

### SQL문의 데이터 처리 순서

~~~
- SQL문에서는 데이터의 조건이나 관계를 기술
	- SELECT A FROM B WHERE C = 1
	- 오라클은 힌트를 활용해서 어느정도의 처리순서를 지시함.
- 옵티마이저가(파서)가 SQL문을 분석하고 플랜이라고 하는 처리 방법을 생성
~~~

### 서버 프로세스와 분석

~~~
- 서버 프로세스는 SQL문의 처리를 최우선으로 하는 프로세스
- 오라클에서 분석은 SQL문을 분석하고 어떤 알고리즘으로 처리할 지를 가리킴
	- 비용 기반 알고리즘 : 처리 시간이나 I/O 횟수가 가장 작다고 생각되는 처리방법이 최상의 알고리즘
~~~

[분석 그림]

![분석이란](https://user-images.githubusercontent.com/40616436/70139798-9a8d8600-16d6-11ea-810f-be0176c9d68a.jpg)

### 비용의 수치 통계정보

~~~
- 테이블의 데이터 건 수, 데이터 양, 데이터 최댓값과 최솟값, 인덱스에 관한 기초 수치를 말함
- 오라클 10g 부터는 SQL문 정보, 파라미터 정보(사용할 수 있는 자원 정보), 시스템 통계 정보(한번 작업하는데 걸리는 시간)를 가지고 비용을 계산
~~~

**분석은 테이블 수가 많으면 많아질 수록 RDBMS가 좋지 않은 실행 계획을 선택하게 된다.

**그 이유는? 선택할 수 있는 실행 계획의 수가 많다는 점과 이런 실행 계획들이 어디까지나 예측에 지나지 않다는 점이다.



### 공유 풀의 동작과 구조

~~~
- 분석 처리가 많은 CPU를 사용하고 있다는 문제를 발견
- 이를 해결하기 위해, 실행 계획을 공유해서 자원 소비를 줄일 수 있는 방안을 생각
- 공유 풀은 실행 계획을 재이용하고 분석 작업을 줄이기 위한 존재
- 공유 풀을 잘 활용하게 되면 CPU 자원의 절약으로 이어짐
~~~



### 공유 풀의 동작원리

![공유풀의 동작원리](https://user-images.githubusercontent.com/40616436/70142478-ab40fa80-16dc-11ea-989c-217b360faef2.jpg)

~~~
- 공유 풀도 프로세스 간의 공유를 하므로 공유 메모리 안에 있음.
- 공유 풀은 라이브러리 캐시와 딕셔너리 캐시 영역을 가짐
	- 라이브러리 캐시 : 실행계획 등 SQL 정보의 캐시는 여기에서 수행
	- 딕셔너리 캐시   : 통계 정보의 캐시 등 주로 SQL의 실행에 필요한 메타 정보를 보관
~~~



### 오라클은 어떻게 같은 SQL 문이라고 판단하나?

~~~
- 오라클은 해시 알고리즘(빠른 검색을 위한 알고리즘)을 사용해서 SQL문 마다 ID를 생성
	- SQL문을 문자열로 해시 함수에 입력하고 함수에서 출력된 해시 값을 SQL문의 ID로 활용
	- 대소문자에 따라 해시값은 달라짐
- 검색 조건이 다른 SQL문은 바인드 변수를 사용하면 같은 SQL문으로 판단
	- 바인드 변수 : 프로그램의 변수를 SQL문에서 사용하는 기능
	- Ex. where cust_no = :변수명
~~~



### 하드 파스와 소프트 파스

~~~
- 하드 파스 : 지금까지 해왔던 분석(SQL문 분석)
- 소프트 파스 : 해시 값을 요청한 결과, 공유 풀에 캐시되어 있는 실행 계획을 찾았기 때문에 재이용하는 경우
~~~



### 정리

** 결과적으로, 실행 계획을 생성하기 위해서는 분석이 필요하고 이 분석은 많은 양의 CPU를 사용하기 때문에 공유 풀에 실행계획을 캐시해서 재활용 함.

** 현장에서는, 비용 계산의 기초 정보가 되는 통계 정보가 제대로 수집되고 있는지 DBA에게 확인

** 하드 피스가 많으며 분석에 사용하는 CPU양이 많을 시에는, SQL문을 바인드 변수를 사용하도록 변경



[오라클 전체 그림]

![오라클 전체 그림](https://user-images.githubusercontent.com/40616436/70143347-aed58100-16de-11ea-879c-65de96e37572.jpg)



## 오라클의 기동과 정지

### 오라클의 기동/정지 개요

~~~
[창고 회사 오라클의 업무 시작 흐름]
1. 사원 출근
2. 창고에 관한 정보(관리 대장)를 조사
3. 창고를 대충 훑어본 뒤 문제 없을 시 창고를 열어 업무 시작

[창고 회사 오라클의 업무 종료 흐름]
1. 업무(SQL이나 트랜잭션)가 끝나는 것을 기다림 | 급할 때는 업무 처리 중지 가능
2. 작업장의 물건(캐시상의 데이터)을 창고(파일)에 정리 | 급할 때는 작업장의 물건들을 정리하지 않음
3. 사원이 퇴근(프로세스 종료)
~~~



### 오라클 기동 4가지 상태

![오라클 기동 네가지](https://user-images.githubusercontent.com/40616436/70143784-d6791900-16df-11ea-8f10-b5b573ef722d.jpg)

### 오라클의 작업 흐름

~~~
- 퇴근 : 정지 상태
- 출근 : 백그라운드 프로세스의 생성과 공유메모리의 확보를 의미
- 관리대장 읽음 : 컨트롤 파일(DB의 구성정보가 적혀 있는 파일로서, DB 파일의 경로 확인 가능) 봄
- 업무 중 : SQL 및 데이터 처리 가능
~~~



### 인스턴스와 DB

~~~
- 인스턴스 : 백그라운드 프로세스 + 공유 메모리 | NOMOUNT 상태가 인스턴스를 기동한 상태
- 일반적으로 인스턴스와 DB는 1:1로 대응 즉, 인스턴스 기동 시 DB 기동했다는 것과 같은 의미
	- RAC(클러스터링 기능)을 사용한 경우 인스턴스와 DB는 1:1로 대응하지 않음
	- DB(1) : 인스턴스(N)
~~~



### 기동 처리의 흐름과 내부 동작

~~~
1. 기동 정지 상태에서 NOMOUNT로 전환
	- 환경 변수 ORACLE_HOME과 ORACLE_SID를 토대로 초기화 파라미터 파일은 찾아서 읽음
	- 읽어 온 파라미터를 토대로 공유 메모리를 확보하고 백그라운드 프로세스를 생성
2. NOMOUNT에서 MOUNT로 전환
	- 관리대장을 읽는 것으로 초기화 파라미터 파일에 적혀있는 컨트롤 파일 위치를 확인 후 컨트롤 파일을 열어 내용을 읽어 옴.
	- 이로 인해, 오라클은 리두 로그 파일이나 데이터 파일의 위치를 파악 할 수 있음.
3. MOUNT에서 OPEN으로 전환
	- 데이터 파일을 열어 읽고 기록, 점검하거나 백그라운드 프로세스를 기동

순서로 보게되면, 초기화 파라미터 파일 열음 -> 컨트롤 파일 열음() -> 데이터 파일 열음
~~~



### 업무 종료에 해당하는 오라클의 정지

~~~
- 오라클의 정지는 기동 작업의 역순으로 DB를 닫은 후 인스턴스를 종료
- 인스턴스 종료는 공유 메모리를 반환하고 백그라운드 프로세스를 정지하는 것을 말함
- 기동 작업의 역순으로 진행하되 중간에 버퍼 캐시에 분산된 데이터를 정리하는 작업도 포함
~~~



### shutdown의 옵션과 그 동작

~~~
- 옵션 없음 : 접속의 종료를 기다림 | 변경된 데이터를 데이터 파일에 기록함
- transactional : 트랜잭션이 끝나면 접속을 끊음 | 변경된 데이터를 데이터 파일에 기록함
- immediate : 접속 종료를 기다리지 않고, 커밋 안할 시 데이터 없어짐 | 변경된 데이터를 데이터 파일에 기록함
- abort : 접속 종료를 기다리지 않고, 커밋 안할 시 데이터 없어짐 | 변경된 데이터를 데이터 파일에 기록안함

[인스턴스 복구]
- abort는 데이터를 기록하지 않지만 인스턴스 복구가 일어남 | 리두 로그 파일의 데이터를 사용해서 복구
- 오라클이 비정상적으로 종료했을 때도 인스턴스 복구가 일어남
- 단, 파일에 관한 장애가 발생했을 경우에는 본격적인 복구가 일어남
~~~



### 정리

** 컨트롤 파일은 데이터 파일 등의 구성 정보가 들어있으므로, 데이터 파일의 추가/삭제, 리두 로그 파일에 관한 것을 변경했을 경우에는 컨트롤 파일을 백업해 두도록 하는 것이 좋음



[오라클 아키텍처 정리]

![오라클 아키텍처 정리](https://user-images.githubusercontent.com/40616436/70145091-a717db80-16e2-11ea-8ea2-955c78fa6474.jpg)



## 커넥션과 서버 프로세스의 생성

### 애플리케이션의 커넥션을 왜 배워야 하는가?

~~~
- 애플리케이션의 커넥션을 최적화 하는 것만으로도 DB의 성능을 더욱 끌어올릴 수 있음.
- 애플리케이션과 오라클이 네트워크를 통해서 통신하는 경우가 많음
	- 그로인해 설정으로 인한 장애가 쉽게 발생하며, 간단한 장애일 때는 아키텍처를 이해할 시 쉽게 해결할 수 있음
~~~



### 오라클의 커넥션 동작 - 소켓

~~~
- 오라클은 네트워크 통신 수단으로서 대부분 TCP/IP의 소켓을 사용
	- 소켓을 전화라고 생각하면 이해하기 쉬움
- 네트워크 안에는 여러개의 소켓이 존재함
	- 틀리지 않고 커넥션 하기 위해서 소켓은 주소와 포트를 조합한 번호로 식별이 가능

[커넥션 동작]
1. 서버는 특정 포트번호로 오는 것을 기다림(listen 상태)
2. 클라이언트는 커넥션 하고 싶은 상대의 DB서버의 주소와 리스너 포트 번호를 향해 송신
3. 서버는 클라이언트의 요청에 응답
~~~



### 오라클에서 소켓의 동작

~~~
1. 리스너 : 오라클에서 수신을 기다리는 프로세스
	- 리스너는 listner.ora에서 자신이 listen해야할 포트번호(보통 1521)를 확인 후 listen을 진행
2. 애플리케이션 프로세스 : 리스너로 커넥션 하는 프로세스
	- tnsnames.ora파일을 확인하여 커넥션 디스크립터(DB서버 주소나 리스너의 포트번호, 서비스 이름)을 확인
	- 커넥션 디스크립터를 오라클 클라이언트에게 전달
	- 오라클 클라이언트는 커넥션 디스크립터를 활용해서 애플리케이션 프로세스와 리스너 사이에 소켓을 생성하고, 리스너에게 이 DB와 통신하고 싶다라는 연락을 취함
3. 서버 프로세스
	- 소켓을 생성하면 리스너는 서버 프로세스를 생성해서 소켓을 서버 프로세스에게 전달하고 모든 처리를 인계함
		- 이유는? 한번 SQL을 처리하면 다른 처리를 진행할 수 없으므로.. 리스너는 할 일이 많나봐
	- 서버 프로세스는 공유 메모리도 사용하고 메모리도 확보하고 DB 내부의 처리도 해야함
    - 서버 프로세스는 오랜 시간동안 CPU를 사용
~~~



![오라클 커넥션의 개요](https://user-images.githubusercontent.com/40616436/70145753-29ed6600-16e4-11ea-8aaf-4aa0d7c10fed.jpg)

### 각 프로세스의 정지나 리스너의 상태 확인

~~~
- 애플리케이션에서 접속을 종료하면 서버 프로세스도 종료됨
- 리스너는 lsnrctl 명령어를 사용하여 정지
- lsnrctl의 status 명령어로 리스너의 가동 상태나 listen 하고 있는 포트 번호, 유지하고 있는 DB 정보를 알 수 있음
~~~



### 좀 더 성능을 개선하려면

~~~
- 서버 프로세스는 SQL을 처리하는 프로세스이므로, 한 번 처리를 시작하면 끝날 때까지 다른 작업을 할 수 없음
- 그로 인해, 여러 서버 프로세스가 여러 클라이언트의 SQL을 처리할 수 있도록 하면 효율이 높아질거 같다.
- 즉, 서버 프로세스 몇 개를 풀로 사용하게 만들어 두고 여러 애플리케이션이 자신이 쓰고 싶을 때만 풀에서 하나를 꺼내 사용한다는 구조 - 커넥션 풀
~~~

![커넥션 풀 구조](https://user-images.githubusercontent.com/40616436/70146885-7f2a7700-16e6-11ea-97ce-15eb17cea06c.jpg)



### 정리

![오라클 아키텍처 정리_리스너 및 서버 프로세스](https://user-images.githubusercontent.com/40616436/70147073-e5af9500-16e6-11ea-98e0-b50edd6b3545.jpg)